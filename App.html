<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Markdown Vault Notes</title>
<style>
  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    height: 100vh;
    display: flex;
    background: #fafafa;
    color: #212529;
  }

  /* Vaults sidebar */
  #vaults-list {
    width: 20%;
    background: #e9ecef;
    border-right: 1px solid #ddd;
    display: flex;
    flex-direction: column;
    box-shadow: inset -1px 0 5px rgba(0,0,0,0.05);
  }

  #vaults-list-header {
    padding: 18px;
    background: #0d6efd;
    color: white;
    font-size: 1.3em;
    text-align: center;
    font-weight: 700;
    flex-shrink: 0;
    letter-spacing: 1px;
    user-select: none;
  }

  #new-vault-btn, #remove-vault-btn {
    background: white;
    border: none;
    padding: 10px;
    margin: 12px 15px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    color: #0d6efd;
    border: 2px solid #0d6efd;
    transition: background-color 0.25s, color 0.25s;
    font-size: 1em;
    user-select: none;
  }

  #new-vault-btn:hover, #remove-vault-btn:hover:not(:disabled) {
    background: #0d6efd;
    color: white;
  }

  #remove-vault-btn:disabled {
    background: #dee2e6;
    border-color: #dee2e6;
    color: #6c757d;
    cursor: not-allowed;
  }

  #vaults-list ul {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #0d6efd #dee2e6;
  }

  #vaults-list ul::-webkit-scrollbar {
    width: 8px;
  }

  #vaults-list ul::-webkit-scrollbar-track {
    background: #dee2e6;
    border-radius: 6px;
  }

  #vaults-list ul::-webkit-scrollbar-thumb {
    background-color: #0d6efd;
    border-radius: 6px;
  }

  #vaults-list ul li {
    padding: 12px 18px;
    border-bottom: 1px solid #ccc;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 1.1em;
    transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
    border-left: 4px solid transparent;
  }

  #vaults-list ul li.active,
  #vaults-list ul li:hover {
    background: #cfe2ff;
    color: #084298;
    font-weight: 700;
    border-left-color: #0d6efd;
    box-shadow: inset 3px 0 8px rgba(13,110,253,0.2);
  }

  #vaults-list ul li.empty-message {
    cursor: default;
    font-style: italic;
    color: #6c757d;
  }

  /* Notes sidebar */
  #notes-list {
    width: 28%;
    background: #f8f9fa;
    border-right: 1px solid #ddd;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    box-shadow: inset -1px 0 5px rgba(0,0,0,0.05);
  }

  #notes-list-header {
    padding: 18px;
    background: #198754;
    color: white;
    font-size: 1.3em;
    text-align: center;
    font-weight: 700;
    flex-shrink: 0;
    letter-spacing: 1px;
    user-select: none;
  }

  #new-note-btn {
    background: white;
    border: none;
    padding: 12px;
    margin: 12px 15px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    color: #198754;
    border: 2px solid #198754;
    transition: background-color 0.25s, color 0.25s;
    font-size: 1em;
    user-select: none;
  }

  #new-note-btn:hover {
    background: #198754;
    color: white;
  }

  #notes-list ul {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #198754 #e9ecef;
  }

  #notes-list ul::-webkit-scrollbar {
    width: 8px;
  }

  #notes-list ul::-webkit-scrollbar-track {
    background: #e9ecef;
    border-radius: 6px;
  }

  #notes-list ul::-webkit-scrollbar-thumb {
    background-color: #198754;
    border-radius: 6px;
  }

  #notes-list ul li {
    padding: 14px 18px;
    border-bottom: 1px solid #ddd;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 1.05em;
    transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
    border-left: 4px solid transparent;
  }

  #notes-list ul li.active,
  #notes-list ul li:hover {
    background: #d1e7dd;
    color: #0f5132;
    font-weight: 700;
    border-left-color: #198754;
    box-shadow: inset 3px 0 8px rgba(25,135,84,0.2);
  }

  #notes-list ul li.empty-message {
    cursor: default;
    font-style: italic;
    color: #6c757d;
  }

  /* Editor section */
  #editor {
    flex-grow: 1;
    padding: 24px;
    display: flex;
    flex-direction: column;
    background: white;
    height: 100vh;
    box-sizing: border-box;
  }

  #editor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    gap: 12px;
  }

  #note-title {
    font-size: 1.8em;
    padding: 14px 18px;
    border: 1px solid #ced4da;
    border-radius: 10px;
    flex-grow: 1;
    font-weight: 600;
    color: #212529;
    transition: border-color 0.3s, box-shadow 0.3s;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: text;
  }

  #note-title::placeholder {
    color: #adb5bd;
  }

  #note-title:focus {
    outline: none;
    border-color: #198754;
    box-shadow: 0 0 8px #198754aa;
  }

  #toggle-mode-btn {
    padding: 10px 22px;
    background: #0d6efd;
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    user-select: none;
    font-weight: 700;
    font-size: 1em;
    transition: background-color 0.3s, box-shadow 0.3s;
    flex-shrink: 0;
  }

  #toggle-mode-btn:hover:not(:disabled) {
    background: #0b5ed7;
    box-shadow: 0 0 8px #0b5ed7cc;
  }

  #toggle-mode-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
  }

  #delete-note-btn {
    padding: 10px 20px;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    user-select: none;
    font-weight: 700;
    font-size: 1em;
    transition: background-color 0.3s, box-shadow 0.3s;
    flex-shrink: 0;
  }

  #delete-note-btn:hover:not(:disabled) {
    background: #b02a37;
    box-shadow: 0 0 8px #b02a37cc;
  }

  #delete-note-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
  }

  #toolbar {
    margin-bottom: 12px;
    user-select: none;
  }

  #toolbar button {
    background: #e9ecef;
    border: none;
    padding: 8px 12px;
    margin-right: 6px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    color: #495057;
    transition: background-color 0.25s, color 0.25s;
    font-size: 1em;
    user-select: none;
  }

  #toolbar button:hover:not(:disabled) {
    background: #0d6efd;
    color: white;
  }

  #toolbar button:disabled {
    background: #ced4da;
    cursor: not-allowed;
    color: #6c757d;
  }

  #editor-textarea {
    flex-grow: 1;
    width: 100%;
    font-size: 1.15em;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 18px;
    border: 1px solid #ced4da;
    border-radius: 12px;
    resize: none;
    line-height: 1.5;
    color: #212529;
    background: white;
  }

  #editor-textarea:focus {
    outline: none;
    border-color: #0d6efd;
    box-shadow: 0 0 12px #0d6efdaa;
  }

  #preview {
    flex-grow: 1;
    width: 100%;
    padding: 18px;
    border: 1px solid #ced4da;
    border-radius: 12px;
    background: white;
    overflow-y: auto;
    font-size: 1.15em;
    line-height: 1.5;
    color: #212529;
  }

  /* Scrollbars for preview */
  #preview::-webkit-scrollbar {
    width: 10px;
  }

  #preview::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 10px;
  }

  #preview::-webkit-scrollbar-thumb {
    background: #0d6efd;
    border-radius: 10px;
  }

  /* Editor container with toggle mode */
  #editor-container {
    display: flex;
    flex-grow: 1;
    gap: 12px;
    height: calc(100vh - 114px);
  }

  /* Editor textarea and preview when side by side */
  #editor-textarea, #preview {
    height: 100%;
  }

  /* Stacked mode (preview hidden) */
  #editor.stacked #preview {
    display: none;
  }

  /* Stacked mode (textarea full width) */
  #editor.stacked #editor-textarea {
    width: 100%;
  }
</style>
</head>
<body>

<div id="vaults-list">
  <div id="vaults-list-header">Vaults</div>
  <button id="new-vault-btn" title="Add new vault">+ New Vault</button>
  <button id="remove-vault-btn" title="Remove selected vault" disabled>Remove Vault</button>
  <ul id="vaults-ul">
    <!-- Vaults will be dynamically added here -->
  </ul>
</div>

<div id="notes-list">
  <div id="notes-list-header">Notes</div>
  <button id="new-note-btn" title="Add new note" disabled>+ New Note</button>
  <ul id="notes-ul">
    <!-- Notes will be dynamically added here -->
  </ul>
</div>

<div id="editor">
  <div id="editor-header">
    <input id="note-title" placeholder="Select or create a note..." disabled />
    <button id="toggle-mode-btn" title="Toggle preview mode" disabled>Preview</button>
    <button id="delete-note-btn" title="Delete note" disabled>Delete</button>
  </div>

  <div id="toolbar">
    <button data-md="bold" title="Bold (Ctrl+B)" disabled><b>B</b></button>
    <button data-md="italic" title="Italic (Ctrl+I)" disabled><i>I</i></button>
    <button data-md="heading" title="Heading (Ctrl+H)" disabled>H</button>
    <button data-md="code" title="Code (Ctrl+`)" disabled>&lt;/&gt;</button>
    <button data-md="blockquote" title="Blockquote (Ctrl+Q)" disabled>&quot;</button>
    <button data-md="ulist" title="Unordered List (Ctrl+U)" disabled>&bull;</button>
    <button data-md="olist" title="Ordered List (Ctrl+O)" disabled>1.</button>
    <button data-md="link" title="Link (Ctrl+L)" disabled>üîó</button>
    <button data-md="image" title="Image (Ctrl+G)" disabled>üñºÔ∏è</button>
  </div>

  <div id="editor-container">
    <textarea id="editor-textarea" placeholder="Write your markdown note here..." disabled></textarea>
    <div id="preview"></div>
  </div>
</div>

<script>
  // DATA STRUCTURE:
  // vaults = [{id, name, notes: [{id, title, content}]}]
  let vaults = [];
  let selectedVaultId = null;
  let selectedNoteId = null;
  let previewMode = false;

  // DOM Elements
  const vaultsUl = document.getElementById('vaults-ul');
  const notesUl = document.getElementById('notes-ul');
  const newVaultBtn = document.getElementById('new-vault-btn');
  const removeVaultBtn = document.getElementById('remove-vault-btn');
  const newNoteBtn = document.getElementById('new-note-btn');
  const noteTitleInput = document.getElementById('note-title');
  const toggleModeBtn = document.getElementById('toggle-mode-btn');
  const deleteNoteBtn = document.getElementById('delete-note-btn');
  const editorTextarea = document.getElementById('editor-textarea');
  const previewDiv = document.getElementById('preview');
  const editorDiv = document.getElementById('editor');
  const toolbarButtons = document.querySelectorAll('#toolbar button');

  // Utility to generate unique IDs
  function generateId() {
    return 'id-' + Math.random().toString(36).slice(2, 12);
  }

  // Save vaults to localStorage
  function saveData() {
    localStorage.setItem('markdownVaults', JSON.stringify(vaults));
  }

  // Load vaults from localStorage
  function loadData() {
    const data = localStorage.getItem('markdownVaults');
    if (data) {
      try {
        vaults = JSON.parse(data);
      } catch {
        vaults = [];
      }
    } else {
      vaults = [];
    }
    if (vaults.length > 0) {
      selectedVaultId = vaults[0].id;
      if (vaults[0].notes.length > 0) {
        selectedNoteId = vaults[0].notes[0].id;
      }
    }
  }

  // RENDER VAULTS
  function renderVaults() {
    vaultsUl.innerHTML = '';
    if (vaults.length === 0) {
      const li = document.createElement('li');
      li.className = 'empty-message';
      li.textContent = 'No vaults. Create one!';
      vaultsUl.appendChild(li);
      selectedVaultId = null;
      selectedNoteId = null;
      updateRemoveVaultButton();
      updateNewNoteBtn();
      renderNotes();
      renderEditor();
      updatePreview();
      return;
    }
    vaults.forEach(vault => {
      const li = document.createElement('li');
      li.textContent = vault.name;
      li.dataset.id = vault.id;
      if (vault.id === selectedVaultId) {
        li.classList.add('active');
      }
      li.addEventListener('click', () => {
        if (selectedVaultId !== vault.id) {
          selectedVaultId = vault.id;
          selectedNoteId = vault.notes.length > 0 ? vault.notes[0].id : null;
          renderVaults();
          renderNotes();
          renderEditor();
          updatePreview();
          updateRemoveVaultButton();
          updateNewNoteBtn();
        }
      });
      vaultsUl.appendChild(li);
    });
    updateRemoveVaultButton();
  }

  // RENDER NOTES
  function renderNotes() {
    notesUl.innerHTML = '';
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault || vault.notes.length === 0) {
      const li = document.createElement('li');
      li.className = 'empty-message';
      li.textContent = 'No notes in this vault.';
      notesUl.appendChild(li);
      selectedNoteId = null;
      updateNewNoteBtn();
      renderEditor();
      updatePreview();
      return;
    }
    vault.notes.forEach(note => {
      const li = document.createElement('li');
      li.textContent = note.title || 'Untitled';
      li.dataset.id = note.id;
      if (note.id === selectedNoteId) {
        li.classList.add('active');
      }
      li.addEventListener('click', () => {
        if (selectedNoteId !== note.id) {
          selectedNoteId = note.id;
          renderNotes();
          renderEditor();
          updatePreview();
          updateDeleteNoteBtn();
        }
      });
      notesUl.appendChild(li);
    });
    updateNewNoteBtn();
    updateDeleteNoteBtn();
  }

  // RENDER EDITOR (title and content)
  function renderEditor() {
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault || !selectedNoteId) {
      noteTitleInput.value = '';
      noteTitleInput.disabled = true;
      editorTextarea.value = '';
      editorTextarea.disabled = true;
      toggleModeBtn.disabled = true;
      deleteNoteBtn.disabled = true;
      toolbarButtons.forEach(btn => btn.disabled = true);
      previewDiv.innerHTML = '';
      editorDiv.classList.remove('stacked');
      previewMode = false;
      toggleModeBtn.textContent = 'Preview';
      return;
    }
    const note = vault.notes.find(n => n.id === selectedNoteId);
    if (!note) return;
    noteTitleInput.disabled = false;
    editorTextarea.disabled = false;
    toggleModeBtn.disabled = false;
    deleteNoteBtn.disabled = false;
    toolbarButtons.forEach(btn => btn.disabled = false);

    noteTitleInput.value = note.title || '';
    editorTextarea.value = note.content || '';
    updatePreview();
  }

  // UPDATE PREVIEW
  function updatePreview() {
    if (!selectedVaultId || !selectedNoteId) {
      previewDiv.innerHTML = '';
      return;
    }
    let md = editorTextarea.value;
    previewDiv.innerHTML = markdownToHtml(md);
  }

  // MARKDOWN TO HTML (basic)
  function markdownToHtml(md) {
    // VERY basic markdown rendering: bold, italic, headings, code blocks, blockquotes, lists, links, images
    let html = md
      // Escape HTML entities first
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")

      // Code blocks ```
      .replace(/```([\s\S]*?)```/g, (_, code) => `<pre><code>${code.trim()}</code></pre>`)

      // Inline code `code`
      .replace(/`([^`\n]+)`/g, '<code>$1</code>')

      // Headings #####
      .replace(/^###### (.*)$/gm, '<h6>$1</h6>')
      .replace(/^##### (.*)$/gm, '<h5>$1</h5>')
      .replace(/^#### (.*)$/gm, '<h4>$1</h4>')
      .replace(/^### (.*)$/gm, '<h3>$1</h3>')
      .replace(/^## (.*)$/gm, '<h2>$1</h2>')
      .replace(/^# (.*)$/gm, '<h1>$1</h1>')

      // Bold **text**
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')

      // Italic *text*
      .replace(/\*(.*?)\*/g, '<em>$1</em>')

      // Blockquotes
      .replace(/^> (.*)$/gm, '<blockquote>$1</blockquote>')

      // Ordered lists
      .replace(/^\d+\. (.*)$/gm, '<li>$1</li>')
      .replace(/(<li>.*<\/li>)/gms, '<ol>$1</ol>')

      // Unordered lists
      .replace(/^\* (.*)$/gm, '<li>$1</li>')
      .replace(/(<li>.*<\/li>)/gms, '<ul>$1</ul>')

      // Links [text](url)
      .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>')

      // Images ![alt](url)
      .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img alt="$1" src="$2" style="max-width: 100%; height: auto;">')

      // Paragraphs for lines not wrapped in tags
      .replace(/^(?!<(h\d|ul|ol|li|blockquote|pre|code|img|a))(.+)$/gm, '<p>$2</p>');

    return html;
  }

  // Update Remove Vault button enabled/disabled
  function updateRemoveVaultButton() {
    removeVaultBtn.disabled = !selectedVaultId;
  }

  // Update New Note button enabled/disabled
  function updateNewNoteBtn() {
    newNoteBtn.disabled = !selectedVaultId;
  }

  // Update Delete Note button enabled/disabled
  function updateDeleteNoteBtn() {
    deleteNoteBtn.disabled = !selectedNoteId;
  }

  // EVENTS

  // New Vault button
  newVaultBtn.addEventListener('click', () => {
    let name = prompt('Enter vault name:');
    if (!name) return;
    name = name.trim();
    if (name === '') return alert('Vault name cannot be empty.');
    if (vaults.some(v => v.name.toLowerCase() === name.toLowerCase())) {
      return alert('A vault with this name already exists.');
    }
    const newVault = {id: generateId(), name, notes: []};
    vaults.push(newVault);
    selectedVaultId = newVault.id;
    selectedNoteId = null;
    saveData();
    renderVaults();
    renderNotes();
    renderEditor();
    updatePreview();
  });

  // Remove Vault button
  removeVaultBtn.addEventListener('click', () => {
    if (!selectedVaultId) return;
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault) return;

    if (!confirm(`Are you sure you want to remove the vault "${vault.name}" and all its notes? This action cannot be undone.`)) {
      return;
    }

    vaults = vaults.filter(v => v.id !== selectedVaultId);

    // Update selected vault and note
    if (vaults.length > 0) {
      selectedVaultId = vaults[0].id;
      selectedNoteId = vaults[0].notes.length > 0 ? vaults[0].notes[0].id : null;
    } else {
      selectedVaultId = null;
      selectedNoteId = null;
    }

    saveData();
    renderVaults();
    renderNotes();
    renderEditor();
    updatePreview();
  });

  // New Note button
  newNoteBtn.addEventListener('click', () => {
    if (!selectedVaultId) return;
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault) return;

    let title = prompt('Enter note title:');
    if (title === null) return;
    title = title.trim();
    if (title === '') title = 'Untitled';

    const newNote = {id: generateId(), title, content: ''};
    vault.notes.unshift(newNote); // Add to front for quick access

    selectedNoteId = newNote.id;
    saveData();
    renderNotes();
    renderEditor();
    updatePreview();
  });

  // Note title input
  noteTitleInput.addEventListener('input', () => {
    if (!selectedVaultId || !selectedNoteId) return;
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault) return;
    const note = vault.notes.find(n => n.id === selectedNoteId);
    if (!note) return;

    note.title = noteTitleInput.value.trim() || 'Untitled';
    saveData();
    renderNotes();
  });

  // Editor textarea input
  editorTextarea.addEventListener('input', () => {
    if (!selectedVaultId || !selectedNoteId) return;
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault) return;
    const note = vault.notes.find(n => n.id === selectedNoteId);
    if (!note) return;

    note.content = editorTextarea.value;
    saveData();
    updatePreview();
  });

  // Toggle preview mode button
  toggleModeBtn.addEventListener('click', () => {
    previewMode = !previewMode;
    if (previewMode) {
      editorDiv.classList.add('stacked');
      toggleModeBtn.textContent = 'Edit';
    } else {
      editorDiv.classList.remove('stacked');
      toggleModeBtn.textContent = 'Preview';
    }
  });

  // Delete note button
  deleteNoteBtn.addEventListener('click', () => {
    if (!selectedVaultId || !selectedNoteId) return;
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault) return;
    const note = vault.notes.find(n => n.id === selectedNoteId);
    if (!note) return;

    if (!confirm(`Are you sure you want to delete the note "${note.title}"? This action cannot be undone.`)) {
      return;
    }

    vault.notes = vault.notes.filter(n => n.id !== selectedNoteId);
    selectedNoteId = vault.notes.length > 0 ? vault.notes[0].id : null;
    saveData();
    renderNotes();
    renderEditor();
    updatePreview();
  });

  // Toolbar buttons (bold, italic, heading, code, etc.)
  toolbarButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      if (!selectedVaultId || !selectedNoteId) return;

      const mdCommand = btn.dataset.md;
      if (!mdCommand) return;

      applyMarkdownCommand(mdCommand);
    });
  });

  // Apply markdown command to selected text in editor
  function applyMarkdownCommand(command) {
    const textarea = editorTextarea;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    let selectedText = textarea.value.substring(start, end);
    let before = textarea.value.substring(0, start);
    let after = textarea.value.substring(end);
    let newText = '';
    let newCursorPos = end;

    switch(command) {
      case 'bold':
        if (selectedText) {
          newText = `**${selectedText}**`;
          newCursorPos = start + newText.length;
        } else {
          newText = `****`;
          newCursorPos = start + 2;
        }
        break;

      case 'italic':
        if (selectedText) {
          newText = `*${selectedText}*`;
          newCursorPos = start + newText.length;
        } else {
          newText = `**`;
          newCursorPos = start + 1;
        }
        break;

      case 'heading':
        // Add # at start of line(s)
        const lines = selectedText.split('\n');
        for(let i=0; i<lines.length; i++) {
          if (!lines[i].startsWith('#')) {
            lines[i] = '# ' + lines[i];
          }
        }
        newText = lines.join('\n');
        newCursorPos = start + newText.length;
        break;

      case 'code':
        if (selectedText) {
          newText = `\`${selectedText}\``;
          newCursorPos = start + newText.length;
        } else {
          newText = '``';
          newCursorPos = start + 1;
        }
        break;

      case 'blockquote':
        const bqLines = selectedText.split('\n').map(line => '> ' + line);
        newText = bqLines.join('\n');
        newCursorPos = start + newText.length;
        break;

      case 'ulist':
        const ulLines = selectedText.split('\n').map(line => `* ${line}`);
        newText = ulLines.join('\n');
        newCursorPos = start + newText.length;
        break;

      case 'olist':
        const olLines = selectedText.split('\n').map((line, i) => `${i+1}. ${line}`);
        newText = olLines.join('\n');
        newCursorPos = start + newText.length;
        break;

      case 'link':
        if (selectedText) {
          newText = `[${selectedText}](url)`;
          newCursorPos = start + newText.length - 4; // Place cursor inside url
        } else {
          newText = `[text](url)`;
          newCursorPos = start + 1;
        }
        break;

      case 'image':
        if (selectedText) {
          newText = `![alt](${selectedText})`;
          newCursorPos = start + newText.length;
        } else {
          newText = `![alt](url)`;
          newCursorPos = start + 6;
        }
        break;

      default:
        return;
    }

    const updatedContent = before + newText + after;
    editorTextarea.value = updatedContent;

    // Update note content in data
    const vault = vaults.find(v => v.id === selectedVaultId);
    if (!vault) return;
    const note = vault.notes.find(n => n.id === selectedNoteId);
    if (!note) return;
    note.content = updatedContent;
    saveData();

    // Set cursor position
    textarea.focus();
    textarea.selectionStart = textarea.selectionEnd = newCursorPos;

    updatePreview();
  }

  // Keyboard shortcuts for markdown commands
  document.addEventListener('keydown', (e) => {
    if (!selectedVaultId || !selectedNoteId) return;
    if (e.ctrlKey || e.metaKey) {
      switch(e.key.toLowerCase()) {
        case 'b':
          e.preventDefault();
          applyMarkdownCommand('bold');
          break;
        case 'i':
          e.preventDefault();
          applyMarkdownCommand('italic');
          break;
        case 'h':
          e.preventDefault();
          applyMarkdownCommand('heading');
          break;
        case '`':
          e.preventDefault();
          applyMarkdownCommand('code');
          break;
        case 'q':
          e.preventDefault();
          applyMarkdownCommand('blockquote');
          break;
        case 'u':
          e.preventDefault();
          applyMarkdownCommand('ulist');
          break;
        case 'o':
          e.preventDefault();
          applyMarkdownCommand('olist');
          break;
        case 'l':
          e.preventDefault();
          applyMarkdownCommand('link');
          break;
        case 'g':
          e.preventDefault();
          applyMarkdownCommand('image');
          break;
      }
    }
  });

  // INITIAL LOAD
  loadData();
  renderVaults();
  renderNotes();
  renderEditor();
  updatePreview();
</script>

</body>
</html>
